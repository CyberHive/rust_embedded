/* automatically generated by rust-bindgen 0.60.1 */

pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const SIN_ZERO_LEN: u32 = 8;
pub const MEMP_NUM_NETCONN: u32 = 8;
pub const FD_SETSIZE: u32 = 8;
pub const IOCPARM_MASK: u32 = 127;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = core::ffi::c_longlong;
pub type uintmax_t = core::ffi::c_ulonglong;
pub type u8_t = u8;
pub type s8_t = i8;
pub type u16_t = u16;
pub type s16_t = i16;
pub type u32_t = u32;
pub type s32_t = i32;
pub type mem_ptr_t = usize;
pub type ssize_t = core::ffi::c_int;
pub type size_t = core::ffi::c_int;
extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
pub type err_t = s8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
#[test]
fn bindgen_test_layout_ip4_addr() {
    assert_eq!(
        ::core::mem::size_of::<ip4_addr>(),
        4usize,
        concat!("Size of: ", stringify!(ip4_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<ip4_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip4_addr))
    );
    fn test_field_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ip4_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip4_addr),
                "::",
                stringify!(addr)
            )
        );
    }
    test_field_addr();
}
pub type ip4_addr_t = ip4_addr;
pub type ip_addr_t = ip4_addr_t;
extern "C" {
    pub fn ipaddr_addr(cp: *const core::ffi::c_char) -> u32_t;
}
extern "C" {
    pub fn ip4addr_aton(cp: *const core::ffi::c_char, addr: *mut ip4_addr_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip4addr_ntoa(addr: *const ip4_addr_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn ip4addr_ntoa_r(
        addr: *const ip4_addr_t,
        buf: *mut core::ffi::c_char,
        buflen: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
pub type in_addr_t = u32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::core::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    fn test_field_s_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<in_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in_addr),
                "::",
                stringify!(s_addr)
            )
        );
    }
    test_field_s_addr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in6_addr {
    pub s6_addr: [u8_t; 16usize],
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::core::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr>(),
        1usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    fn test_field_s6_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<in6_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).s6_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr),
                "::",
                stringify!(s6_addr)
            )
        );
    }
    test_field_s6_addr();
}
pub type sa_family_t = u8_t;
pub type in_port_t = u16_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: u8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [core::ffi::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    fn test_field_sin_len() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_len)
            )
        );
    }
    test_field_sin_len();
    fn test_field_sin_family() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_family)
            )
        );
    }
    test_field_sin_family();
    fn test_field_sin_port() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_port)
            )
        );
    }
    test_field_sin_port();
    fn test_field_sin_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_addr)
            )
        );
    }
    test_field_sin_addr();
    fn test_field_sin_zero() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_zero)
            )
        );
    }
    test_field_sin_zero();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: u8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    fn test_field_sin6_len() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin6_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_len)
            )
        );
    }
    test_field_sin6_len();
    fn test_field_sin6_family() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_family)
            )
        );
    }
    test_field_sin6_family();
    fn test_field_sin6_port() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_port)
            )
        );
    }
    test_field_sin6_port();
    fn test_field_sin6_flowinfo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_flowinfo)
            )
        );
    }
    test_field_sin6_flowinfo();
    fn test_field_sin6_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_addr)
            )
        );
    }
    test_field_sin6_addr();
    fn test_field_sin6_scope_id() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_scope_id)
            )
        );
    }
    test_field_sin6_scope_id();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: u8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [core::ffi::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    fn test_field_sa_len() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_len)
            )
        );
    }
    test_field_sa_len();
    fn test_field_sa_family() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_family)
            )
        );
    }
    test_field_sa_family();
    fn test_field_sa_data() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_data)
            )
        );
    }
    test_field_sa_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub s2_len: u8_t,
    pub ss_family: sa_family_t,
    pub s2_data1: [core::ffi::c_char; 2usize],
    pub s2_data2: [u32_t; 3usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::core::mem::size_of::<sockaddr_storage>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_storage>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    fn test_field_s2_len() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).s2_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(s2_len)
            )
        );
    }
    test_field_s2_len();
    fn test_field_ss_family() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(ss_family)
            )
        );
    }
    test_field_ss_family();
    fn test_field_s2_data1() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).s2_data1) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(s2_data1)
            )
        );
    }
    test_field_s2_data1();
    fn test_field_s2_data2() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).s2_data2) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(s2_data2)
            )
        );
    }
    test_field_s2_data2();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut core::ffi::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::core::mem::size_of::<iovec>(),
        8usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<iovec>(),
        4usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    fn test_field_iov_base() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_base)
            )
        );
    }
    test_field_iov_base();
    fn test_field_iov_len() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_len)
            )
        );
    }
    test_field_iov_len();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::core::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    fn test_field_imr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ip_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq),
                "::",
                stringify!(imr_multiaddr)
            )
        );
    }
    test_field_imr_multiaddr();
    fn test_field_imr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ip_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq),
                "::",
                stringify!(imr_interface)
            )
        );
    }
    test_field_imr_interface();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::core::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::core::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    fn test_field_ipv6mr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ipv6_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_mreq),
                "::",
                stringify!(ipv6mr_multiaddr)
            )
        );
    }
    test_field_ipv6mr_multiaddr();
    fn test_field_ipv6mr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ipv6_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_mreq),
                "::",
                stringify!(ipv6mr_interface)
            )
        );
    }
    test_field_ipv6mr_interface();
}
pub type nfds_t = core::ffi::c_uint;
pub type socklen_t = u32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fd_bits: [core::ffi::c_uchar; 1usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        1usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        1usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field_fd_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fd_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(fd_bits)
            )
        );
    }
    test_field_fd_bits();
}
pub const SOCK_STREAM: core::ffi::c_int = 1;
pub const SOCK_DGRAM: core::ffi::c_int = 2;
pub const SOCK_RAW: core::ffi::c_int = 3;
pub const SO_REUSEADDR: core::ffi::c_int = 4;
pub const SO_KEEPALIVE: core::ffi::c_int = 8;
pub const SO_BROADCAST: core::ffi::c_int = 32;
pub const SO_DEBUG: core::ffi::c_int = 1;
pub const SO_ACCEPTCONN: core::ffi::c_int = 2;
pub const SO_DONTROUTE: core::ffi::c_int = 16;
pub const SO_USELOOPBACK: core::ffi::c_int = 64;
pub const SO_LINGER: core::ffi::c_int = 128;
pub const SO_DONTLINGER: core::ffi::c_int = -129;
pub const SO_OOBINLINE: core::ffi::c_int = 256;
pub const SO_REUSEPORT: core::ffi::c_int = 512;
pub const SO_SNDBUF: core::ffi::c_int = 4097;
pub const SO_RCVBUF: core::ffi::c_int = 4098;
pub const SO_SNDLOWAT: core::ffi::c_int = 4099;
pub const SO_RCVLOWAT: core::ffi::c_int = 4100;
pub const SO_SNDTIMEO: core::ffi::c_int = 4101;
pub const SO_RCVTIMEO: core::ffi::c_int = 4102;
pub const SO_ERROR: core::ffi::c_int = 4103;
pub const SO_TYPE: core::ffi::c_int = 4104;
pub const SO_CONTIMEO: core::ffi::c_int = 4105;
pub const SO_NO_CHECK: core::ffi::c_int = 4106;
pub const SO_BINDTODEVICE: core::ffi::c_int = 4107;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: core::ffi::c_int,
    pub l_linger: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::core::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::core::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    fn test_field_l_onoff() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<linger>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linger),
                "::",
                stringify!(l_onoff)
            )
        );
    }
    test_field_l_onoff();
    fn test_field_l_linger() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<linger>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(linger),
                "::",
                stringify!(l_linger)
            )
        );
    }
    test_field_l_linger();
}
pub const SOL_SOCKET: core::ffi::c_int = 4095;
pub const AF_UNSPEC: core::ffi::c_int = 0;
pub const AF_INET: core::ffi::c_int = 2;
pub const AF_INET6: core::ffi::c_int = 0;
pub const IPPROTO_IP: core::ffi::c_int = 0;
pub const IPPROTO_ICMP: core::ffi::c_int = 1;
pub const IPPROTO_TCP: core::ffi::c_int = 6;
pub const IPPROTO_UDP: core::ffi::c_int = 17;
pub const IPPROTO_IPV6: core::ffi::c_int = 41;
pub const IPPROTO_ICMPV6: core::ffi::c_int = 58;
pub const IPPROTO_UDPLITE: core::ffi::c_int = 136;
pub const IPPROTO_RAW: core::ffi::c_int = 255;
pub const MSG_PEEK: core::ffi::c_int = 1;
pub const MSG_WAITALL: core::ffi::c_int = 2;
pub const MSG_OOB: core::ffi::c_int = 4;
pub const MSG_DONTWAIT: core::ffi::c_int = 8;
pub const MSG_MORE: core::ffi::c_int = 16;
pub const MSG_NOSIGNAL: core::ffi::c_int = 32;
pub const IP_TOS: core::ffi::c_int = 1;
pub const IP_TTL: core::ffi::c_int = 2;
pub const IP_PKTINFO: core::ffi::c_int = 8;
pub const TCP_NODELAY: core::ffi::c_int = 1;
pub const TCP_KEEPALIVE: core::ffi::c_int = 2;
pub const TCP_KEEPIDLE: core::ffi::c_int = 3;
pub const TCP_KEEPINTVL: core::ffi::c_int = 4;
pub const TCP_KEEPCNT: core::ffi::c_int = 5;
pub const FIONBIO: core::ffi::c_long = -2147195266;
pub const F_GETFL: core::ffi::c_int = 3;
pub const F_SETFL: core::ffi::c_int = 4;
pub const O_NONBLOCK: core::ffi::c_int = 1;
pub const O_NDELAY: core::ffi::c_int = 1;
pub const O_RDONLY: core::ffi::c_int = 2;
pub const O_WRONLY: core::ffi::c_int = 4;
pub const O_RDWR: core::ffi::c_int = 6;
pub const SHUT_RD: core::ffi::c_int = 0;
pub const SHUT_WR: core::ffi::c_int = 1;
pub const SHUT_RDWR: core::ffi::c_int = 2;
pub const POLLIN: i16 = 1;
pub const POLLOUT: i16 = 2;
pub const POLLERR: i16 = 4;
pub const POLLNVAL: i16 = 8;
pub const POLLHUP: i16 = 512;
pub const IPV6_CHECKSUM: core::ffi::c_int = 7;
pub const IPV6_V6ONLY: core::ffi::c_int = 27;
pub const IP_MULTICAST_TTL: core::ffi::c_int = 5;
pub const IP_MULTICAST_IF: core::ffi::c_int = 6;
pub const IP_MULTICAST_LOOP: core::ffi::c_int = 7;
pub const IP_ADD_MEMBERSHIP: core::ffi::c_int = 3;
pub const IP_DROP_MEMBERSHIP: core::ffi::c_int = 4;
pub const IPV6_JOIN_GROUP: core::ffi::c_int = 12;
pub const IPV6_ADD_MEMBERSHIP: core::ffi::c_int = 12;
pub const IPV6_LEAVE_GROUP: core::ffi::c_int = 13;
pub const IPV6_DROP_MEMBERSHIP: core::ffi::c_int = 13;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: core::ffi::c_int,
    pub events: core::ffi::c_short,
    pub revents: core::ffi::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::core::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::core::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
    fn test_field_revents() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).revents) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(revents)
            )
        );
    }
    test_field_revents();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: core::ffi::c_longlong,
    pub tv_usec: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut core::ffi::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: core::ffi::c_int,
    pub msg_control: *mut core::ffi::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::core::mem::size_of::<msghdr>(),
        28usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<msghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    fn test_field_msg_name() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_name)
            )
        );
    }
    test_field_msg_name();
    fn test_field_msg_namelen() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_namelen)
            )
        );
    }
    test_field_msg_namelen();
    fn test_field_msg_iov() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iov)
            )
        );
    }
    test_field_msg_iov();
    fn test_field_msg_iovlen() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iovlen)
            )
        );
    }
    test_field_msg_iovlen();
    fn test_field_msg_control() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_control)
            )
        );
    }
    test_field_msg_control();
    fn test_field_msg_controllen() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_controllen)
            )
        );
    }
    test_field_msg_controllen();
    fn test_field_msg_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_flags)
            )
        );
    }
    test_field_msg_flags();
}
pub const MSG_TRUNC: core::ffi::c_int = 4;
pub const MSG_CTRUNC: core::ffi::c_int = 8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    #[doc = " pointer to next in linked list"]
    pub next: *mut netif,
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
}
#[test]
fn bindgen_test_layout_netif() {
    assert_eq!(
        ::core::mem::size_of::<netif>(),
        16usize,
        concat!("Size of: ", stringify!(netif))
    );
    assert_eq!(
        ::core::mem::align_of::<netif>(),
        4usize,
        concat!("Alignment of ", stringify!(netif))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<netif>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netif),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_ip_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<netif>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ip_addr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(netif),
                "::",
                stringify!(ip_addr)
            )
        );
    }
    test_field_ip_addr();
    fn test_field_netmask() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<netif>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netif),
                "::",
                stringify!(netmask)
            )
        );
    }
    test_field_netmask();
    fn test_field_gw() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<netif>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).gw) as usize - ptr as usize
            },
            12usize,
            concat!("Offset of field: ", stringify!(netif), "::", stringify!(gw))
        );
    }
    test_field_gw();
}
extern "C" {
    pub fn lwip_accept(
        s: core::ffi::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_bind(
        s: core::ffi::c_int,
        name: *const sockaddr,
        namelen: socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_shutdown(s: core::ffi::c_int, how: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_getpeername(
        s: core::ffi::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_getsockname(
        s: core::ffi::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_getsockopt(
        s: core::ffi::c_int,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: *mut core::ffi::c_void,
        optlen: *mut socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_setsockopt(
        s: core::ffi::c_int,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: *const core::ffi::c_void,
        optlen: socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_close(s: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_connect(
        s: core::ffi::c_int,
        name: *const sockaddr,
        namelen: socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_listen(s: core::ffi::c_int, backlog: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_recv(
        s: core::ffi::c_int,
        mem: *mut core::ffi::c_void,
        len: size_t,
        flags: core::ffi::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn lwip_read(s: core::ffi::c_int, mem: *mut core::ffi::c_void, len: size_t) -> ssize_t;
}
extern "C" {
    pub fn lwip_readv(s: core::ffi::c_int, iov: *const iovec, iovcnt: core::ffi::c_int) -> ssize_t;
}
extern "C" {
    pub fn lwip_recvfrom(
        s: core::ffi::c_int,
        mem: *mut core::ffi::c_void,
        len: size_t,
        flags: core::ffi::c_int,
        from: *mut sockaddr,
        fromlen: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn lwip_recvmsg(
        s: core::ffi::c_int,
        message: *mut msghdr,
        flags: core::ffi::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn lwip_send(
        s: core::ffi::c_int,
        dataptr: *const core::ffi::c_void,
        size: size_t,
        flags: core::ffi::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn lwip_sendmsg(
        s: core::ffi::c_int,
        message: *const msghdr,
        flags: core::ffi::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn lwip_sendto(
        s: core::ffi::c_int,
        dataptr: *const core::ffi::c_void,
        size: size_t,
        flags: core::ffi::c_int,
        to: *const sockaddr,
        tolen: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn lwip_socket(
        domain: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_write(
        s: core::ffi::c_int,
        dataptr: *const core::ffi::c_void,
        size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn lwip_writev(s: core::ffi::c_int, iov: *const iovec, iovcnt: core::ffi::c_int)
        -> ssize_t;
}
extern "C" {
    pub fn lwip_select(
        maxfdp1: core::ffi::c_int,
        readset: *mut fd_set,
        writeset: *mut fd_set,
        exceptset: *mut fd_set,
        timeout: *mut timeval,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_poll(
        fds: *const pollfd,
        nfds: nfds_t,
        timeout: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_ioctl(
        s: core::ffi::c_int,
        cmd: core::ffi::c_long,
        argp: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_fcntl(
        s: core::ffi::c_int,
        cmd: core::ffi::c_int,
        val: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lwip_inet_ntop(
        af: core::ffi::c_int,
        src: *const core::ffi::c_void,
        dst: *mut core::ffi::c_char,
        size: socklen_t,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn lwip_inet_pton(
        af: core::ffi::c_int,
        src: *const core::ffi::c_char,
        dst: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: core::ffi::c_int,
    pub ai_family: core::ffi::c_int,
    pub ai_socktype: core::ffi::c_int,
    pub ai_protocol: core::ffi::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut core::ffi::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::core::mem::size_of::<addrinfo>(),
        32usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<addrinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    fn test_field_ai_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_flags)
            )
        );
    }
    test_field_ai_flags();
    fn test_field_ai_family() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ai_family) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_family)
            )
        );
    }
    test_field_ai_family();
    fn test_field_ai_socktype() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ai_socktype) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_socktype)
            )
        );
    }
    test_field_ai_socktype();
    fn test_field_ai_protocol() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ai_protocol) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_protocol)
            )
        );
    }
    test_field_ai_protocol();
    fn test_field_ai_addrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ai_addrlen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_addrlen)
            )
        );
    }
    test_field_ai_addrlen();
    fn test_field_ai_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ai_addr) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_addr)
            )
        );
    }
    test_field_ai_addr();
    fn test_field_ai_canonname() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ai_canonname) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_canonname)
            )
        );
    }
    test_field_ai_canonname();
    fn test_field_ai_next() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).ai_next) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_next)
            )
        );
    }
    test_field_ai_next();
}
extern "C" {
    pub fn lwip_freeaddrinfo(ai: *mut addrinfo);
}
extern "C" {
    pub fn lwip_getaddrinfo(
        nodename: *const core::ffi::c_char,
        servname: *const core::ffi::c_char,
        hints: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> core::ffi::c_int;
}
